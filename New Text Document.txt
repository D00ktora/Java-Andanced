
==================================================================================================================

Functional Programing


    Function<приема, връща> -> apply
    Consumer<приема> -> void -> accept
    Supplier<връща> -> get
    Predicate<приема> -> връща true / false -> test
    BiFunction<приема1, приема2, връща> -> apply


==================================================================================================================

Матрици - теория

    1. съхраняваме данни в матрица

    private static void fillMatrix(int[][] matrix, Scanner scanner) {
        for (int row = 0; row < matrix.length ; row++) {
            for (int col = 0; col < matrix.length; col++) {
                matrix[row][col] = scanner.nextInt();
            }
        }
    }


    private static void fillMatrix(double[][] matrix, Scanner scanner) {
        for (int row = 0; row < matrix.length ; row++) {
            for (int col = 0; col < matrix.length; col++) {
                matrix[row][col] = scanner.nextDouble();
            }
        }
    }

    private static void fillMatrix(String[][] matrix, Scanner scanner) {
        for (int row = 0; row < matrix.length ; row++) {
            //scanner.nextLine() -> "1 2 3"
            //scanner.nextLine().split(" ") -> ["1", "2", "3"]
            matrix[row] = scanner.nextLine().split("\\s+");
        }
    }

    2. извеждане на данни от матрица

    private static void printMatrix(int[][] matrix) {
        for (int row = 0; row < matrix.length; row++) {
            for (int col = 0; col < matrix.length; col++) {
                System.out.print(matrix[row][col] + " ");
            }
            System.out.println(); //свали курсора на следващия ред
        }
    }

    3. диагонали в квадратна матрица

    - главен диагонал -> индекс на ред = индекс на колона
    - второстепенния диагонал -> индекс на колона = размер на матрица - индекс на ред - 1

    4. валидираме индекси

    при правоъгълна матрица:
        - брой редове -> matrix.lenght
        - брой на колони -> matrix[0].lenght

    при квадратна матрица:
        - брой редове -> matrix.lenght
        - брой на колони -> matrix.lenght

    - валиден ред: ред >= 0 и ред < брой на редове
    - невалиден ред: ред < 0 или ред >= брой на редове

    - валидна колона: колона >= 0 и колона < брой на колони
    - валидна колона: колона < 0 или колона >= брой на колона

    5. движения в матрица
        - ляво с 1 позиция -> колона - 1
        - дясно с 1 позиция -> колона + 1
        - надолу с 1 позиция -> ред + 1
        - нагоре с 1 позиция -> ред - 1

==================================================================================================================

Set
    - структура от данни, в която съхраняваме уникални елементи
    - видове:
        1. HashSet - нямаме специфична подредба на елементи
        2. LinkedHashSet - редът на добавяне на елементите се запазва
        3. TreeSet - елементите се сортират в ascending order

Map
    - съвкупност от записи
    - запис: ключ -> стойност
    - всички ключове са уникални
    - видове:
        1. HashMap - нямаме специфична подредба на записи
        2. LinkedHashMap - редът на добавяне на записи се запазва
        3. TreeMap - записи се сортират в ascending order спрямо техния ключ

==================================================================================================================

STACK (LIFO) -> купчина от книги
    добавяне -> push
    премахване -> pop
    преглед -> peek

QUEUE (FIFO) -> опашка в магазин
    добавяне -> offer (add)
    премахване -> poll (remove)
    преглед -> peek


    List / Array -> искаме да имаме пряк достъп до всички елементи
    list = {1, 5, 6, 7, 8} -> list.get(5)
    array = [2, 4, 5, 6, 8] -> array[3]

    Stack / Queue -> искаме да имаме достъп до първия  / последния
    Stack -> последния добавен елемент
    Queue -> първия добавен елемент


    При избор на структутра от данни, в която ще съхранявам:
    1. Кои елементи ще достъпвам?
    - всички -> list / array
    - първи / последния -> stack / queue

    2. Ако ще използвам list или array?
    - list -> ако искаме да модифицираме елементите
    - array -> ако искаме само да съхраняваме, без много модификации

    3. Ако ще използвам stack или queue?
    - stack -> ако искаме достъп до последния елемент
    - queue -> ако искаме достъп до първия елемент


==================================================================================================================
Масиви int[]

    1. Четене на масив директно от конзолата
        int[] someName = Arrays.stream(scanner.nextLine().split("some regex"))
                                .mapToInt( i -> Integer.parseInt(i))
                                .toArray();

==================================================================================================================

Листве - List<>

    1. Четене на лист от конзолата
        List<тип данни> name = Arrays.stream(scanner.nextLine().split("някакъв регекс"))
                                    .map(Integer::parseInt)
                                    .collect(Collectors.toList());

    2. Смяна на типа на листа към сртринг
        List<String> result = nameOfList.stream()
                                    .map(String::valueOf)
                                    .collect(Collectors.toList());

    3. От някакъв лист към String за принтиране
        String result = nameOfList.stream()
                                    .map(String::valueOf)
                                    .collect(Collectors.joining("разделител"));

==================================================================================================================

Comparable -> compareTo -> Сравним
    Пише се в нашия клас.
    Чрез него определяме дефоутното сравнение на класа.
Comparator -> compare -> Сравнител
    Създава се чрез външен клас
    Можем да имаме колкото си искаме такива сравнители

==================================================================================================================

Iterable -> Нещо, което може да се итерира
Iterator -> Нещо, което извършва действието по итериране.
Двете работят заедно, с Iterable казваме че може да се итерира и после имплементираме Iterator чрез който итерираме.

==================================================================================================================
